// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// Defines values for Result.
const (
	Player1Wins Result = "Player1Wins"
	Player2Wins Result = "Player2Wins"
	Tie         Result = "Tie"
	Undefined   Result = "Undefined"
)

// Defines values for Turn.
const (
	TurnPlayer1 Turn = "TurnPlayer1"
	TurnPlayer2 Turn = "TurnPlayer2"
)

// BoardSide A side of the board
type BoardSide struct {
	// Pits The pits of the board side
	Pits   []int64 `json:"pits"`
	Player Player  `json:"player"`

	// Store The store (big pit) of the board side
	Store int64 `json:"store"`
}

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Game defines model for Game.
type Game struct {
	// BoardSide1 A side of the board
	BoardSide1 BoardSide `json:"board_side1"`

	// BoardSide2 A side of the board
	BoardSide2 BoardSide `json:"board_side2"`

	// Id The id of the game
	Id string `json:"id"`

	// Result The result of the game
	Result Result `json:"result"`

	// Turn The turn that needs to play next
	Turn Turn `json:"turn"`
}

// Player defines model for Player.
type Player struct {
	// Name The name of the player
	Name string `json:"name"`

	// Score The score of the player
	Score int64 `json:"score"`
}

// Result The result of the game
type Result string

// Turn The turn that needs to play next
type Turn string

// GameID defines model for GameID.
type GameID = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// PlayCreated defines model for PlayCreated.
type PlayCreated struct {
	Game           Game  `json:"game"`
	PlayedPitIndex int64 `json:"played_pit_index"`
}

// NewGameBody defines model for NewGameBody.
type NewGameBody struct {
	Player1 string `json:"player1"`
	Player2 string `json:"player2"`
}

// NewPlayBody defines model for NewPlayBody.
type NewPlayBody struct {
	PitIndex int64 `json:"pit_index"`
}

// CreateGameJSONBody defines parameters for CreateGame.
type CreateGameJSONBody struct {
	Player1 string `json:"player1"`
	Player2 string `json:"player2"`
}

// CreatePlayJSONBody defines parameters for CreatePlay.
type CreatePlayJSONBody struct {
	PitIndex int64 `json:"pit_index"`
}

// CreateGameJSONRequestBody defines body for CreateGame for application/json ContentType.
type CreateGameJSONRequestBody CreateGameJSONBody

// CreatePlayJSONRequestBody defines body for CreatePlay for application/json ContentType.
type CreatePlayJSONRequestBody CreatePlayJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Render API docs page
	// (GET /docs)
	RenderDocs(ctx echo.Context) error
	// Render swagger JSON
	// (GET /swagger.json)
	RenderSwagger(ctx echo.Context) error
	// Create game
	// (POST /v1/games)
	CreateGame(ctx echo.Context) error
	// Show game
	// (GET /v1/games/{id})
	ShowGame(ctx echo.Context, id GameID) error
	// Perform next play
	// (POST /v1/games/{id}/plays)
	CreatePlay(ctx echo.Context, id GameID) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// RenderDocs converts echo context to params.
func (w *ServerInterfaceWrapper) RenderDocs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RenderDocs(ctx)
	return err
}

// RenderSwagger converts echo context to params.
func (w *ServerInterfaceWrapper) RenderSwagger(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RenderSwagger(ctx)
	return err
}

// CreateGame converts echo context to params.
func (w *ServerInterfaceWrapper) CreateGame(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateGame(ctx)
	return err
}

// ShowGame converts echo context to params.
func (w *ServerInterfaceWrapper) ShowGame(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id GameID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ShowGame(ctx, id)
	return err
}

// CreatePlay converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePlay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id GameID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePlay(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/docs", wrapper.RenderDocs)
	router.GET(baseURL+"/swagger.json", wrapper.RenderSwagger)
	router.POST(baseURL+"/v1/games", wrapper.CreateGame)
	router.GET(baseURL+"/v1/games/:id", wrapper.ShowGame)
	router.POST(baseURL+"/v1/games/:id/plays", wrapper.CreatePlay)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8RY32/bthP/Vwh+vw8bwFR2fnXVW7t2gYeuC5IUewiCgBbPNguJ1Eg6iRHofx+O1E+L",
	"sZOgW5GHSOLx7j6fO94d/UgzXZRagXKWpo8UHnhR5uCfz3O++RTe8fWO52v/sOSF/z/X3IhbKwVM8bWU",
	"qOJ6wt42fzeMljnfgMFl5Xd5pWCmlFGbaQM0nVSMWucfpxXrKT3sKT1l7d/TSg+jSvFRCprSo7fiZH50",
	"kh0s3k3g4Hh6dHrwbrL45eBkMhGn2fHRfDpfUEYN2HXuOk//kspSRt3aqJ77Ve2FuC2lu5VKwANNT6oK",
	"v3PDC3BgPIlnvIDZR3ySuL/kbkVZ47cU3uDfa2lA0NSZNSCEFRQcd7hNiVLWGamW1CtHYbDugxYyBOkL",
	"3KOJD1ps8DXTyoFy+MjLMpcZd1Kr5JvVCr91ukujSzCu1lLWsNJHWkj1GdTSrWg6ZdsuNNwf7pWs+sCu",
	"WwOdgpt2i55/g8x1+DoyKob4kPMX4+NCSFzi+XkP6YLnFtg2+C6Cj3ShTcEx/FK502PKaMEfZLEuaHrC",
	"EHF4nrTOS+VgCWYMuFX6LKD+iy21ssGnD1xchFC/CPX/DSxoSv+XdKc6Cas2+WSMNsG4AJsZWaISmtKr",
	"FZA6r8g9t0SqO55LgdGeKQdG8fwSzB2YoOFf96cxSqy3SiAIMvpFu9/0Won/hhJbQiYXEgQxYPXaZODZ",
	"UdqRhfeiYr4c/GqAO3iOU9vF9Sn3GrmkX4HRyaeOb1ORd2HFKhEvW98v6b0fERPxIzCkHLGSrOayAxtO",
	"AzaFSyk8yOG29wR7BdEL4lZAfPegkQNuxzsxxrgy2Ou1UUalg8LGqdlBhyduFraetsvcGL7paue+QIUW",
	"Q7sOFnPcL5Gf5nKJGH6OYhi5vr9kYacLVltvx7FjtC0EQ54LsJYvIda6hpYy7R1s5GMmzuqUHlrYGjl2",
	"0djlzHiqePY+KeL0S9EwXqf8qE82Y8RuYxdBqmrmi93SVyizzWU9Q3g9tRo24GmIPsb1eZuXQ7ZVHYMx",
	"flxpGKjzJMJBPYxF8xeXRhpemrEqkB/sxJBdtFGItTxc24ojKDza1/SrErCQCpDc4SBYz5r125XsG+6g",
	"X9XhHJvFCBG34o4oAGGJ0x4/UfDgeg6ggm5W7t4OI+aQFqkWGg3mMgNloTcc/zG78gkmXe5fucp4zsn7",
	"8xll9A6MDb5N30zeTFBQl6B4KXFi9p+YH1p9QiRCZ6HhgCcVk8W3uBkO2BegBJiPKLI1zRxOJlvt0cGD",
	"S1auyIfNuk0AvxQFulX+z2dE6GxdgHLek9A61kXBzab1idRilpRYbxh1fInXCuqdvcEtib3nyyWYN02z",
	"3gHxMojuR/maETVcAva2y9oH8vvln1/imG1fIgr5bppg2oceqW0Eb5htzsLZ6O4eT04ug+tJ0r+bVCOy",
	"ps+fmPYOSmimHZTYM6e/MBGNqcXv3STC6HGIaxxvDSnpDewVoyfP2RIbroeRDPS3PaaO4JmP2TCEyaMU",
	"VS9th4guwBkJd2AJb5QN43y50vdtlF+c0j8sSiE6x/upbm8O3y82SNlTkRn+CHAdN9aJJPWPBNXNKKQJ",
	"9oZwQF+nkbUne0jf11Jw1yYEmW98F5Jq6bthpk3gQuAXbE2knixi9cHfZV5XH9q7/RP1YXeU+tev1x3U",
	"H5U952Cw1wVqy8Df6HzjDq8hhHwYwM8649gi1yb3/dKVaZLk+HGlrUunR4dHmFD/BAAA//+vqXAV4RMA",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
